import { useState } from 'react';
import { GAME_CONFIG } from '../data/gameConfig';
import { MINISTRY_TYPES } from '../data/ministryTypes';
import { 
  generateTerritory, 
  calculateFinances, 
  calculateHappiness,
  calculatePopulationGrowth,
  autoFillJobs
} from '../utils/calculations';
import { 
  TECHNOLOGIES, 
  canResearch, 
  calculateResearchSpeed, 
  applyTechEffects 
} from '../data/technologies';

export const useGameLogic = () => {
  const [gameState, setGameState] = useState('setup');
  const [president, setPresident] = useState({ name: '', nationName: '' });
  const [nation, setNation] = useState(null);
  const [notifications, setNotifications] = useState([]);

  // Sistema de Notifica√ß√µes
  const addNotification = (message, type = 'info') => {
    const id = Date.now() + Math.random(); // Garante ID √∫nico
    setNotifications(prev => [...prev, { id, message, type }]);
    setTimeout(() => {
      setNotifications(prev => prev.filter(n => n.id !== id));
    }, 5000);
  };

  // Iniciar Jogo
  const startGame = (name, nationName) => {
    if (!name || !nationName) {
      addNotification('Preencha todos os campos!', 'error');
      return;
    }

    const territory = generateTerritory();
    const initialNation = {
      territory,
      population: GAME_CONFIG.INITIAL_POPULATION,
      treasury: GAME_CONFIG.INITIAL_TREASURY,
      currentMonth: 1,
      happiness: 50,
      stats: {
        education: 0,
        health: 0,
        security: 0,
        food: 0,
        economy: 0,
        research: 0,
        energy: 0,
        resources: 0
      },
      workers: {
        common: GAME_CONFIG.INITIAL_POPULATION,
        employed: 0
      },
      ministries: [],
      facilities: [],
      technologies: {
        researching: [],
        researched: []
      }
    };

    setPresident({ name, nationName });
    setNation(initialNation);
    setGameState('playing');
    addNotification('üéâ Bem-vindo! Sua na√ß√£o foi fundada com sucesso!', 'success');
  };

  // Criar Minist√©rio
  const createMinistry = (type) => {
    if (!nation) return;

    if (nation.treasury < GAME_CONFIG.MINISTRY_COST) {
      addNotification('Tesouro insuficiente para criar minist√©rio!', 'error');
      return;
    }

    if (nation.ministries.find(m => m.type === type)) {
      addNotification('Este minist√©rio j√° existe!', 'warning');
      return;
    }

    const ministryData = MINISTRY_TYPES[type];
    if (!ministryData) {
      addNotification('Tipo de minist√©rio inv√°lido!', 'error');
      return;
    }

    const newMinistry = {
      id: Date.now(),
      type,
      ...ministryData,
      minister: null
    };

    setNation(prev => ({
      ...prev,
      ministries: [...prev.ministries, newMinistry],
      treasury: prev.treasury - GAME_CONFIG.MINISTRY_COST
    }));

    addNotification(`‚úÖ Minist√©rio de ${ministryData.name} criado com sucesso!`, 'success');
  };

  // Contratar Ministro
  const hireMinister = (ministryId, salary) => {
    if (!nation) return;

    if (nation.treasury < salary) {
      addNotification('Tesouro insuficiente para pagar o sal√°rio do ministro!', 'error');
      return;
    }

    if (salary < 1000) {
      addNotification('Sal√°rio muito baixo! M√≠nimo recomendado: R$ 1.000', 'warning');
      return;
    }

    const ministry = nation.ministries.find(m => m.id === ministryId);
    if (!ministry) {
      addNotification('Minist√©rio n√£o encontrado!', 'error');
      return;
    }

    if (ministry.minister) {
      addNotification('Este minist√©rio j√° tem um ministro!', 'warning');
      return;
    }

    setNation(prev => ({
      ...prev,
      ministries: prev.ministries.map(m =>
        m.id === ministryId
          ? { ...m, minister: { name: `Ministro ${m.name}`, salary } }
          : m
      ),
      treasury: prev.treasury - salary
    }));

    addNotification(`üëî Ministro contratado com sucesso! Sal√°rio: R$ ${salary.toLocaleString()}`, 'success');
  };

  // Criar Benfeitoria
  const createFacility = (ministryId, facilityData) => {
    if (!nation) return;

    if (nation.treasury < facilityData.cost) {
      addNotification(
        `üí∞ Tesouro insuficiente! Necess√°rio R$ ${facilityData.cost.toLocaleString()}`,
        'error'
      );
      return;
    }

    const ministry = nation.ministries.find(m => m.id === ministryId);
    if (!ministry) {
      addNotification('Minist√©rio n√£o encontrado!', 'error');
      return;
    }

    if (!ministry.minister) {
      addNotification('Contrate um ministro antes de construir benfeitorias!', 'warning');
      return;
    }

    const newFacility = {
      id: Date.now(),
      ministryId,
      name: facilityData.name,
      cost: facilityData.cost,
      benefits: facilityData.benefits || {},
      researchSpeed: facilityData.researchSpeed || 0,
      jobs: facilityData.jobs.map(job => ({ 
        ...job, 
        filled: 0, 
        currentSalary: job.minSalary 
      })),
      appliedTechs: []
    };

    // Aplicar tecnologias j√° pesquisadas
    const updatedFacility = applyTechEffects(
      newFacility, 
      nation.technologies?.researched || []
    );

    setNation(prev => ({
      ...prev,
      facilities: [...prev.facilities, updatedFacility],
      treasury: prev.treasury - facilityData.cost
    }));

    addNotification(`üèóÔ∏è ${facilityData.name} constru√≠da com sucesso!`, 'success');
  };

  // Atualizar Sal√°rio de Cargo
  const updateJobSalary = (facilityId, role, newSalary) => {
    if (!nation) return;

    const facility = nation.facilities.find(f => f.id === facilityId);
    if (!facility) {
      addNotification('Benfeitoria n√£o encontrada!', 'error');
      return;
    }

    const job = facility.jobs.find(j => j.role === role);
    if (!job) {
      addNotification('Cargo n√£o encontrado!', 'error');
      return;
    }

    if (newSalary < job.minSalary) {
      addNotification(
        `‚ö†Ô∏è Sal√°rio abaixo do m√≠nimo! M√≠nimo: R$ ${job.minSalary.toLocaleString()}`,
        'warning'
      );
      return;
    }

    setNation(prev => ({
      ...prev,
      facilities: prev.facilities.map(f =>
        f.id === facilityId
          ? {
              ...f,
              jobs: f.jobs.map(j =>
                j.role === role ? { ...j, currentSalary: newSalary } : j
              )
            }
          : f
      )
    }));

    addNotification(
      `üíµ Sal√°rio de ${role} atualizado para R$ ${newSalary.toLocaleString()}`,
      'success'
    );
  };

  // Iniciar Pesquisa
  const startResearch = (techId) => {
    if (!nation) return;

    const { can, reason } = canResearch(techId, nation);
    
    if (!can) {
      addNotification(reason, 'error');
      return;
    }

    // Verificar limite de pesquisas simult√¢neas
    const currentResearching = nation.technologies?.researching?.length || 0;
    if (currentResearching >= GAME_CONFIG.TECHNOLOGY.MAX_SIMULTANEOUS_RESEARCH) {
      addNotification(
        `‚ö†Ô∏è M√°ximo de ${GAME_CONFIG.TECHNOLOGY.MAX_SIMULTANEOUS_RESEARCH} pesquisas simult√¢neas!`,
        'warning'
      );
      return;
    }

    const tech = TECHNOLOGIES[techId];
    const researchSpeed = calculateResearchSpeed(nation);
    const adjustedTime = Math.max(1, Math.ceil(tech.researchTime / researchSpeed));

    setNation(prev => ({
      ...prev,
      treasury: prev.treasury - tech.cost,
      technologies: {
        ...prev.technologies,
        researching: [
          ...(prev.technologies?.researching || []),
          {
            id: techId,
            progress: 0,
            total: adjustedTime,
            startMonth: prev.currentMonth
          }
        ]
      }
    }));

    addNotification(
      `üî¨ Pesquisa de ${tech.name} iniciada! Conclus√£o em ${adjustedTime} m√™s(es). Velocidade: ${researchSpeed.toFixed(1)}x`,
      'success'
    );
  };

  // Completar Pesquisa
  const completeResearch = (techId) => {
    const tech = TECHNOLOGIES[techId];
    if (!tech) return;

    setNation(prev => {
      // Remover da lista de pesquisas em andamento
      const updatedResearching = prev.technologies.researching.filter(r => r.id !== techId);
      
      // Adicionar √†s pesquisas conclu√≠das
      const updatedResearched = [...(prev.technologies.researched || []), techId];
      
      // Aplicar efeitos da tecnologia em todas as benfeitorias relevantes
      const updatedFacilities = prev.facilities.map(facility => 
        applyTechEffects(facility, updatedResearched)
      );

      return {
        ...prev,
        technologies: {
          ...prev.technologies,
          researching: updatedResearching,
          researched: updatedResearched
        },
        facilities: updatedFacilities
      };
    });

    addNotification(
      `üéâ ${tech.name} conclu√≠da! Benef√≠cios aplicados automaticamente √†s benfeitorias.`,
      'success'
    );
  };

  // Pr√≥ximo Turno (Avan√ßar M√™s)
  const nextTurn = () => {
    if (!nation) return;

    const finances = calculateFinances(nation);
    
    // Verificar se tem dinheiro para pagar as contas
    if (finances.balance < 0 && nation.treasury + finances.balance < 0) {
      addNotification(
        'üö® ALERTA: Tesouro insuficiente para pagar despesas mensais! Ajuste suas finan√ßas!',
        'error'
      );
      return;
    }

    // Calcular felicidade e stats
    const { happiness, stats } = calculateHappiness(nation);
    
    // Calcular crescimento populacional
    const populationGrowth = calculatePopulationGrowth(nation.population, happiness);
    
    // Preencher vagas automaticamente
    const { updatedFacilities, newEmployed } = autoFillJobs(nation);

    // Atualizar progresso de pesquisas
    let completedResearches = [];
    const updatedResearching = (nation.technologies?.researching || []).map(research => {
      const newProgress = research.progress + 1;
      
      if (newProgress >= research.total) {
        completedResearches.push(research.id);
        return null; // Ser√° filtrado
      }
      
      return { ...research, progress: newProgress };
    }).filter(Boolean);

    // Atualizar estado da na√ß√£o
    setNation(prev => ({
      ...prev,
      currentMonth: prev.currentMonth + 1,
      treasury: prev.treasury + finances.balance,
      population: prev.population + populationGrowth,
      happiness,
      stats,
      facilities: updatedFacilities,
      workers: {
        common: prev.workers.common + populationGrowth,
        employed: newEmployed
      },
      technologies: {
        ...prev.technologies,
        researching: updatedResearching
      }
    }));

    // Completar pesquisas finalizadas
    completedResearches.forEach(techId => {
      setTimeout(() => completeResearch(techId), 500);
    });

    // Notifica√ß√µes do turno
    const newMonth = nation.currentMonth + 1;
    
    // Notifica√ß√£o financeira
    addNotification(
      `üìÖ M√™s ${newMonth}: Balan√ßo ${finances.balance >= 0 ? '+' : ''}R$ ${finances.balance.toLocaleString()}`,
      finances.balance >= 0 ? 'success' : 'warning'
    );

    // Notifica√ß√£o de crescimento populacional
    if (populationGrowth > 0) {
      addNotification(
        `üë• Popula√ß√£o cresceu em ${populationGrowth.toLocaleString()} habitantes!`,
        'info'
      );
    }

    // Notifica√ß√£o de pesquisas conclu√≠das
    if (completedResearches.length > 0) {
      addNotification(
        `üî¨ ${completedResearches.length} pesquisa(s) conclu√≠da(s) este m√™s!`,
        'success'
      );
    }

    // Avisos especiais
    if (happiness < GAME_CONFIG.HAPPINESS_THRESHOLD.POOR) {
      addNotification(
        'üò¢ Felicidade muito baixa! Construa benfeitorias de sa√∫de e educa√ß√£o!',
        'warning'
      );
    }

    if (happiness >= GAME_CONFIG.HAPPINESS_THRESHOLD.EXCELLENT) {
      addNotification(
        'üòä Popula√ß√£o extremamente feliz! √ìtimo trabalho!',
        'success'
      );
    }

    const employmentRate = (nation.workers.employed / nation.population);
    if (employmentRate < 0.1) {
      addNotification(
        'üíº Alto desemprego! Crie mais vagas de emprego construindo benfeitorias!',
        'info'
      );
    }

    if (employmentRate > 0.5) {
      addNotification(
        'üëî √ìtima taxa de emprego! Sua economia est√° crescendo!',
        'success'
      );
    }

    // Avisos de tesouro
    if (nation.treasury < 1000000) {
      addNotification(
        '‚ö†Ô∏è Tesouro baixo! Cuidado com gastos excessivos!',
        'warning'
      );
    }

    // Avisos de pesquisa
    if (updatedResearching.length > 0) {
      updatedResearching.forEach(r => {
        const remaining = r.total - r.progress;
        if (remaining === 1) {
          const tech = TECHNOLOGIES[r.id];
          addNotification(
            `üî¨ ${tech.name} ser√° conclu√≠da no pr√≥ximo m√™s!`,
            'info'
          );
        }
      });
    }
  };

  // Retornar todas as fun√ß√µes e estados
  return {
    // Estados
    gameState,
    president,
    nation,
    notifications,
    
    // Fun√ß√µes principais
    startGame,
    createMinistry,
    hireMinister,
    createFacility,
    updateJobSalary,
    nextTurn,
    
    // Fun√ß√µes de tecnologia
    startResearch,
    completeResearch,
    
    // Utilit√°rios
    addNotification
  };
};